--Usage:
--unzip.lua archive.zip <target_directory>
--Be careful, it always overwrites files!
local a={}local bit=bit32 or bit;a.band=bit.band;a.rshift=bit.rshift;function a.bitstream_init(b)local c={file=b,buf=nil,len=nil,pos=1,b=0,n=0}function c:flushb(d)self.n=self.n-d;self.b=bit.rshift(self.b,d)end;function c:next_byte()if self.pos>self.len then self.buf=self.file:read(4096)self.len=self.buf:len()self.pos=1 end;local e=self.pos;self.pos=e+1;return self.buf:byte(e)end;function c:peekb(d)while self.n<d do self.b=self.b+bit.lshift(self:next_byte(),self.n)self.n=self.n+8 end;return bit.band(self.b,bit.lshift(1,d)-1)end;function c:getb(d)local f=c:peekb(d)self.n=self.n-d;self.b=bit.rshift(self.b,d)return f end;function c:getv(g,d)local h=g[c:peekb(d)]local i=bit.band(h,15)local f=bit.rshift(h,4)self.n=self.n-i;self.b=bit.rshift(self.b,i)return f end;function c:close()if self.file then self.file:close()end end;if type(b)=="string"then c.file=nil;c.buf=b else c.buf=b:read(4096)end;c.len=c.buf:len()return c end;local function j(k)local l=#k;local m=1;local n={}local o={}for p=1,l do local q=k[p]if q>m then m=q end;n[q]=(n[q]or 0)+1 end;local table={}local r=0;n[0]=0;for p=1,m do r=(r+(n[p-1]or 0))*2;o[p]=r end;for p=1,l do local i=k[p]or 0;if i>0 then local h=(p-1)*16+i;local r=o[i]local s=0;for t=1,i do s=s+bit.lshift(bit.band(1,bit.rshift(r,t-1)),i-t)end;for t=0,2^m-1,2^i do table[t+s]=h end;o[i]=o[i]+1 end end;return table,m end;local function u(v,c,w,x,y,z)local A;repeat A=c:getv(y,w)if A<256 then table.insert(v,A)elseif A>256 then local m=0;local B=3;local C=1;if A<265 then B=B+A-257 elseif A<285 then m=bit.rshift(A-261,2)B=B+bit.lshift(bit.band(A-261,3)+4,m)else B=258 end;if m>0 then B=B+c:getb(m)end;local D=c:getv(z,x)if D<4 then C=C+D else m=bit.rshift(D-2,1)C=C+bit.lshift(bit.band(D,1)+2,m)C=C+c:getb(m)end;local E=#v-C+1;while B>0 do table.insert(v,v[E])E=E+1;B=B-1 end end until A==256 end;local function F(v,c)local G={17,18,19,1,9,8,10,7,11,6,12,5,13,4,14,3,15,2,16}local H=257+c:getb(5)local I=1+c:getb(5)local J=4+c:getb(4)local k={}for p=1,J do local D=c:getb(3)k[G[p]]=D end;for p=J+1,19 do k[G[p]]=0 end;local K,L=j(k)local p=1;while p<=H+I do local D=c:getv(K,L)if D<16 then k[p]=D;p=p+1 elseif D<19 then local M={2,3,7}local N=M[D-15]local O=0;local d=3+c:getb(N)if D==16 then O=k[p-1]elseif D==18 then d=d+8 end;for t=1,d do k[p]=O;p=p+1 end else error("wrong entry in depth table for literal/length alphabet: "..D)end end;local P={}for p=1,H do table.insert(P,k[p])end;local y,w=j(P)local Q={}for p=H+1,#k do table.insert(Q,k[p])end;local z,x=j(Q)u(v,c,w,x,y,z)end;local function R(v,c)local S={144,112,24,8}local T={8,9,7,8}local k={}for p=1,4 do local q=T[p]for t=1,S[p]do table.insert(k,q)end end;local y,w=j(k)k={}for p=1,32 do k[p]=5 end;local z,x=j(k)u(v,c,w,x,y,z)end;local function U(v,c)c:flushb(bit.band(c.n,7))local i=c:getb(16)if c.n>0 then error("Unexpected.. should be zero remaining bits in buffer.")end;local L=c:getb(16)if bit.bxor(i,L)~=65535 then error("LEN and NLEN don't match")end;for p=1,i do table.insert(v,c:next_byte())end end;function a.main(c)local V,type;local W={}repeat os.queueEvent("nosleep")os.pullEvent()local X;V=c:getb(1)type=c:getb(2)if type==0 then U(W,c)elseif type==1 then R(W,c)elseif type==2 then F(W,c)else error("unsupported block type")end until V==1;c:flushb(bit.band(c.n,7))return W end;local Y;function a.crc32(Z,_)if not Y then Y={}for p=0,255 do local a0=p;for t=1,8 do a0=bit.bxor(bit.rshift(a0,1),bit.band(0xedb88320,bit.bnot(bit.band(a0,1)-1)))end;Y[p]=a0 end end;_=bit.bnot(_ or 0)for p=1,#Z do local O=Z:byte(p)_=bit.bxor(Y[bit.bxor(O,bit.band(_,0xff))],bit.rshift(_,8))end;_=bit.bnot(_)if _<0 then _=_+4294967296 end;return _ end;local a1=a;local unpack=table.unpack or unpack;local a2={}local function a3(a4)local a5={}local B=#a4;local e=1;local a6=1;while B>0 do local a7=B>=2048 and 2048 or B;local Z=string.char(unpack(a4,e,e+a7-1))e=e+a7;B=B-a7;local p=1;while a5[p]do Z=a5[p]..Z;a5[p]=nil;p=p+1 end;if p>a6 then a6=p end;a5[p]=Z end;local a8=""for p=1,a6 do if a5[p]then a8=a5[p]..a8 end end;return a8 end;local function a9(c)local aa,ab,ac,ad=c.buf:byte(1,4)if aa~=31 or ab~=139 then error("invalid gzip header")end;if ac~=8 then error("only deflate format is supported")end;c.pos=11;if a1.band(ad,4)~=0 then local ae,af=c.buf.byte(c.pos,c.pos+1)local ag=af*256+ae;c.pos=c.pos+ag+2 end;if a1.band(ad,8)~=0 then local e=c.buf:find("\0",c.pos)c.pos=e+1 end;if a1.band(ad,16)~=0 then local e=c.buf:find("\0",c.pos)c.pos=e+1 end;if a1.band(ad,2)~=0 then c.pos=c.pos+2 end;local ah=a3(a1.main(c))local _=c:getb(8)+256*(c:getb(8)+256*(c:getb(8)+256*c:getb(8)))c:close()if _~=a1.crc32(ah)then error("checksum verification failed")end;return ah end;local function ai(Z)local aj=1;local ak=0;for p=1,#Z do local O=Z:byte(p)aj=(aj+O)%65521;ak=(ak+aj)%65521 end;return ak*65536+aj end;local function al(c)local am=c.buf:byte(1)local ad=c.buf:byte(2)if(am*256+ad)%31~=0 then error("zlib header check bits are incorrect")end;if a1.band(am,15)~=8 then error("only deflate format is supported")end;if a1.rshift(am,4)~=7 then error("unsupported window size")end;if a1.band(ad,32)~=0 then error("preset dictionary not implemented")end;c.pos=3;local ah=a3(a1.main(c))local an=((c:getb(8)*256+c:getb(8))*256+c:getb(8))*256+c:getb(8)c:close()if an~=ai(ah)then error("checksum verification failed")end;return ah end;local function ao(ap,aq,_)local c=a1.bitstream_init(ap)c.pos=aq;local ah=a3(a1.main(c))if _ and _~=a1.crc32(ah)then error("checksum verification failed")end;return ah end;function a2.gunzipf(ar)local b,as=io.open(ar,"rb")if not b then return nil,as end;return a9(a1.bitstream_init(b))end;function a2.gunzip(a8)return a9(a1.bitstream_init(a8))end;function a2.inflate(a8)return al(a1.bitstream_init(a8))end;local function at(a8,e)local au,av=a8:byte(e,e+1)return av*256+au end;local function aw(a8,e)local au,av,O,q=a8:byte(e,e+3)return((q*256+O)*256+av)*256+au end;local function ax(ap,E)if aw(ap,E)~=0x02014b50 then return end;local ay=at(ap,E+10)~=0;local _=aw(ap,E+16)local az=at(ap,E+28)local aA=ap:sub(E+46,E+45+az)local aq=aw(ap,E+42)+1;E=E+46+az+at(ap,E+30)+at(ap,E+32)if aw(ap,aq)~=0x04034b50 then error("invalid local header signature")end;local B=aw(ap,aq+18)local aB=at(ap,aq+28)aq=aq+30+az+aB;return E,aA,aq,B,ay,_ end;function a2.files(ap)local E=#ap-21;if aw(ap,E)~=0x06054b50 then error("You need to trunc file comments first")end;local aC=aw(ap,E+16)+1;return ax,ap,aC end;function a2.unzip(ap,aD,aE)if type(aD)=="number"then return ao(ap,aD,aE)end;local ar=aD;for aF,aA,aq,B,ay,_ in a2.files(ap)do if aA==ar then local ah;if not ay then ah=ap:sub(aq,aq+B-1)else ah=ao(ap,aq,_)end;return ah end end;error("file '"..ar.."' not found in ZIP archive")end;function a2.trunccomments(ap)local aG=string.find(ap,'PK\5\6')while string.find(ap,'PK\5\6',aG+1)do aG=string.find(ap,'PK\5\6',aG+1)end;if aG then ap=string.sub(ap,1,aG+19)..'\0\0'end;return ap end;local aH,aI=...local aJ=shell.dir()local aK=aI or aJ;local aL=fs.open(fs.combine(aJ,aH),'rb')or fs.open(aH,'rb')local aM=a2.trunccomments(aL.readAll())aL.close()for aF,aA,aq,B,ay,_ in a2.files(aM)do local aN=fs.combine(aK,aA)if string.sub(aA,#aA)=='/'then fs.makeDir(aN)else local W=a2.unzip(aM,aA)local aL=fs.open(aN,"wb")aL.write(W)aL.close()print("Deflated "..aA)end end